<script>
    const COURSES = JSON.parse(`{{ .Site.Data.courses | jsonify (dict "noHTMLEscape" true) }}`);
    const TIMETABLES = JSON.parse(`{{ .Site.Data.timetables | jsonify (dict "noHTMLEscape" true) }}`);
    const HARDCODED_TIMETABLES = JSON.parse(`{{ .Site.Data.hardcodedTimetables | jsonify }}`)
    const COLORS = ['red', 'yellow', 'green', 'blue', 'purple', 'orange', 'emerald', 'cyan', 'fuchsia', 'teal'];
    const DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday']

    for (const courseId in HARDCODED_TIMETABLES) {
        if (TIMETABLES[courseId]) {
            const channelsToUpdate = HARDCODED_TIMETABLES[courseId].channels;

            // Iterate over the channels to be updated
            for (const channelId in channelsToUpdate) {
                TIMETABLES[courseId].channels[channelId] = channelsToUpdate[channelId];
            }
        } else if (HARDCODED_TIMETABLES[courseId]) {
            TIMETABLES[courseId] = HARDCODED_TIMETABLES[courseId];
        }
    }

    // Extract classroom number and its specific suffix
    function getRoomData(roomString) {
        if (!roomString) return null;

        // Regex pattern to match Roman numerals or alphanumeric room identifiers
        const classroomPattern = /\b(Zoom|Meet|I{1,3}|IV|V{1,3}|VI|IX|X|XI bis|XI|Alfa|Magna|G|Tullio)\b|\b[A-Za-z]*\d+[A-Za-z]*\b/;
        const match = roomString.match(classroomPattern);

        if (match) {
            let roomNumber = match[0]; // Extract the matched room number
            let suffix = "";

            // Determine the correct suffix based on the building/location
            if (roomString.includes("Eudossiana")) suffix = " SPV";
            else if (roomString.includes("RM158")) suffix = " DL";     // De Lollis
            else if (roomString.includes("RM112")) suffix = " RE";     // Regina Elena
            else if (roomString.includes("RM113")) suffix = " RE";     // Regina Elena
            else if (roomString.includes("RM005")) suffix = " SC";     // Via Antonio Scarpa
            else if (roomString.includes("RM025")) suffix = " TIB";    // Laboratori Tiburtina
            else if (roomString.includes("CU002")) suffix = " ST";     // Scienze Statistiche
            else if (roomString.includes("RM018")) suffix = "L";       // Aule L Castro Laurenziano

            return { room: roomNumber, suffix: suffix };
        }

        return null; // Return null if no match is found
    }

    // Group classrooms that share the same suffix to avoid repetitions (e.g., "15, 16 TIB")
    function formatClassrooms(roomStringsArray) {
        if (!roomStringsArray || roomStringsArray.length === 0) return null;

        const groups = {};

        // Iterate over the raw room strings to extract and group them by suffix
        for (const roomString of roomStringsArray) {
            const data = getRoomData(roomString);
            if (!data) continue;

            // Initialize the array for a new suffix if it doesn't exist
            if (!groups[data.suffix]) {
                groups[data.suffix] = [];
            }
            groups[data.suffix].push(data.room);
        }

        const result = [];
        for (const suffix in groups) {
            // Join room numbers (e.g., "15, 16") and append the shared suffix at the end
            result.push(groups[suffix].join(', ') + suffix);
        }

        // Join different groups with a separator if they are in different buildings
        return result.length > 0 ? result.join(' - ') : null;
    }

    function fillTimetable(tableId, courses, degreeCourseCodes, channel) {
        let classesStartTime = undefined,
            classesEndTime = undefined;

        const schedule = Object.fromEntries(DAYS.map(day => [day, []]));

        for (const course of courses) {
            const [courseCode, _channel] = course.toString().split('-');

            if (!degreeCourseCodes.includes(courseCode))
                continue;
            if (!TIMETABLES[courseCode])
                continue;

            let requestedChannel = _channel || channel;

            // Get requested channel timetable
            let channelDays = TIMETABLES[courseCode]['channels'][requestedChannel] || {};

            // Always include channel 0 timetable, unless the requested channel is already 0
            let channel0Days = (requestedChannel !== "0")
                ? (TIMETABLES[courseCode]['channels']['0'] || {})
                : {};

            // Merge requested channel with channel 0
            let days = {};
            for (let [day, hours] of Object.entries(channelDays)) {
                days[day] = (days[day] || []).concat(hours);
            }
            for (let [day, hours] of Object.entries(channel0Days)) {
                days[day] = (days[day] || []).concat(hours);
            }

            for (let [day, hours] of Object.entries(days)) {
                if (!Array.isArray(hours))
                    hours = [hours]

                for (const time of hours) {
                    const [startTime, endTime] = time.timeslot.split('-').map(time => parseInt(time))
                    const alerts = COURSES[courseCode].alerts;

                    let cancelled = time.cancelled === true;

                    // Determine the source of classroom information and format it by grouping suffixes
                    let roomArray = [];
                    if (time.classroomInfo) {
                        roomArray = [time.classroomInfo];
                    } else if (time.classrooms) {
                        roomArray = Object.values(time.classrooms);
                    }

                    let classrooms = formatClassrooms(roomArray);

                    let en_day = {
                        'lunedì': 'monday',
                        'martedì': 'tuesday',
                        'mercoledì': 'wednesday',
                        'giovedì': 'thursday',
                        'venerdì': 'friday',
                        'sabato': 'saturday',
                        'domenica': 'sunday',
                    }[day]

                    schedule[en_day].push({ courseCode: courseCode, startTime, endTime, alerts: alerts && alerts[channel] && alerts[channel][day], cancelled: cancelled, classroomDesc: classrooms || null });

                    classesStartTime = Math.min(classesStartTime, startTime) || startTime;
                    classesEndTime = Math.max(classesEndTime, endTime) || endTime;
                }
            }
        }

        let subjectsColors = {}, nextColorIndex = 0;

        const desktopTbody = document.querySelector(`#${tableId} tbody.desktop`);
        const mobileTbody = document.querySelector(`#${tableId} tbody.mobile`);

        desktopTbody.innerHTML = '';
        mobileTbody.innerHTML = '';

        let tableHasAlerts = false;
        for (let time = classesStartTime; time < classesEndTime; time++) {
            const timeTd = document.createElement('td');
            timeTd.classList.add('timetableTableCell', 'font-light', 'italic');
            timeTd.innerHTML = `${time} - ${time + 1}`;

            mobileTimeTd = timeTd.cloneNode(true)
            mobileTimeTd.innerHTML = `${time}-${time + 1}`;

            const desktopTr = document.createElement('tr');
            desktopTr.append(timeTd);

            const mobileTr = document.createElement('tr');
            mobileTr.append(mobileTimeTd);

            for (const day of DAYS) {
                if (!schedule[day])
                    continue;

                const desktopTd = document.createElement('td');
                const mobileTd = document.createElement('td');

                desktopTd.classList.add('timetableTableCell');
                mobileTd.classList.add('timetableTableCell');

                const courses = schedule[day]
                    .filter(({ startTime, endTime }) => startTime <= time && endTime > time);

                let hasMoreThanACourse = false;
                for (const { courseCode, alerts, cancelled, classroomDesc } of courses) {
                    const course = COURSES[courseCode];

                    const desktopCourseLink = document.createElement('a');
                    if (!subjectsColors[courseCode])
                        subjectsColors[courseCode] = COLORS[nextColorIndex++ % COLORS.length];

                    desktopCourseLink.classList.add(subjectsColors[courseCode], 'font-bold', 'underlined-text');
                    if (cancelled) {
                        desktopCourseLink.classList.add('cancelledSchedule');
                    }
                    desktopCourseLink.href = `#${courseCode}`
                    desktopCourseLink.textContent = course ?
                        course.shortName || course.name : courseCode;

                    const mobileCourseLink = desktopCourseLink.cloneNode(true);
                    mobileCourseLink.textContent = course ?
                        course.abbr || course.name.substring(0, 2).toUpperCase() : courseCode;

                    if (mobileCourseLink.textContent.length === 3) mobileCourseLink.style.fontSize = '0.8em';
                    else if (mobileCourseLink.textContent.length === 4) mobileCourseLink.style.fontSize = '0.75em';
                    else if (mobileCourseLink.textContent.length > 4) mobileCourseLink.style.fontSize = '0.7em';
                    else mobileCourseLink.style.fontSize = '0.85em';

                    if (alerts) {
                        desktopCourseLink.textContent += '*';
                        mobileCourseLink.textContent += '*';

                        tableHasAlerts = true;
                    }

                    if (hasMoreThanACourse) {
                        desktopTd.append(document.createElement('br'));
                        mobileTd.append(document.createElement('br'));
                    }

                    hasMoreThanACourse = true;

                    desktopTd.append(desktopCourseLink);
                    mobileTd.append(mobileCourseLink);

                    if (classroomDesc != null) {
                        const desktopClassroomDescElem = document.createElement('div');
                        desktopClassroomDescElem.classList.add('font-italic');
                        desktopClassroomDescElem.textContent = "(" + classroomDesc + ")";

                        const mobileClassroomDescElem = document.createElement('div');
                        mobileClassroomDescElem.classList.add('font-italic');
                        mobileClassroomDescElem.textContent = "(" + classroomDesc + ")";

                        if (mobileClassroomDescElem.textContent.length === 3) mobileClassroomDescElem.style.fontSize = '0.7em';
                        else if (mobileClassroomDescElem.textContent.length === 4) mobileClassroomDescElem.style.fontSize = '0.65em';
                        else if (mobileClassroomDescElem.textContent.length > 4) mobileClassroomDescElem.style.fontSize = '0.6em';
                        else mobileClassroomDescElem.style.fontSize = '0.8em';

                        desktopTd.append(desktopClassroomDescElem);
                        mobileTd.append(mobileClassroomDescElem);
                    }
                }

                desktopTr.append(desktopTd);
                mobileTr.append(mobileTd);
            }

            desktopTbody.append(desktopTr);
            mobileTbody.append(mobileTr);
        }

        let alertsLegend = document.getElementById("alertsLegend");

        if (tableHasAlerts) {
            if (!alertsLegend) {
                alertsLegend = document.createElement("div");
                alertsLegend.id = "alertsLegend";
                alertsLegend.textContent = '* ⚠️ {{ T "Subjs_Timetables_AlertsLegend" }}';

                document.getElementById(tableId).insertAdjacentElement('afterend', alertsLegend);
            }
        } else if (alertsLegend)
            alertsLegend.remove();
    }
</script>